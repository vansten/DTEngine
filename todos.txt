TODOs:
-- GameObject								|> ALL DONE
-- Component								|> ALL DONE
-- Scene									|> ALL DONE
-- Camera 									|> ALL DONE
-- Shader 									|> ALL DONE
-- MeshBase 								|> ALL DONE
-- MeshRenderer								|> ALL DONE
-- HexagonMesh 								|> ALL DONE
-- TriangleMesh								|> ALL DONE
-- CameraControl							|> ALL DONE
-- Asset									|> ALL DONE
-- ResourceManager							|> ALL DONE
-- Transform hierarchy 						|> ALL DONE
-- Material 								|> ALL DONE
-- HexagonalGrid 							|> ALL DONE
-- QuadMesh									|> ALL DONE
-- PlaneMesh 								|> ALL DONE
-- SphereMesh								|> ALL DONE
-- CubeMesh									|> ALL DONE
-- CylinderMesh 							|> ALL DONE
-- ConeMesh									|> ALL DONE
-- CapsuleMesh								|> ALL DONE
-- StaticMesh (obj)							|> ALL DONE
-- Cloning GameObjects						|> ALL DONE
-- Smart pointers + architecture reworked	|> ALL DONE
-- Message passing 							|> ALL DONE
-- Event classes							|> ALL DONE
-- Input adjusted to Delegate class 		|> ALL DONE
-- Debug class + logging					|> ALL DONE
-- Resize window handling					|> ALL DONE
-- Renaming functions in Component 			|> ALL DONE
-- Asset reorganization 					|> ALL DONE
-- Reorganize rendering architecture		|> ALL DONE
-- Debug drawing lines, spheres, boxes 	 	|> ALL DONE
-- Reorganize transform structure 			|> ALL DONE
-- Rename GameObject to Entity				|> ALL DONE
-- Fix frustum culling						|> ALL DONE
-- Default material 						|> ALL DONE
-- Setting shader parameters (reflection)	|> ALL DONE
-- MATH library 							|> ALL DONE
-- Entity flags								|> ALL DONE
-- Debug drawing: custom mesh 				|> ALL DONE
-- Direction to Rotator						|> ALL DONE
-- Layers (for physics and rendering)		|> ALL DONE
-- Physics									|> IN PROGRESS (TODO: PhysicsIssues.txt)
-- Refactor event class 					|> ALL DONE
-- std::function own implementation			|> ALL DONE
-- Selection system
-- Custom collections (DynamicArray? LinkedList? Dictionary? Stack? Queue? PriorityQueue?)
-- Input (gamepad, keyboad, mouse) should be reworked (maybe) from window messages to update and polling keyboard/gamepad/mouse states?
-- General config (fullscreen, vsync mode, target resolution etc., config class which can be easily extensible (i.e. GraphicsConfig, InputConfig etc.))
-- Fullscreen mode (maybe resizing is not properly handled)
-- Rendering performance is an issue. Maybe map is not the best representation for material parameters (or there is a way to have all debugger features and good performance with std::map).
-- Read a little bit about 2D rendering in DX11
-- Textures (2D only for now, simple TGA/PNG loading, UI(SPRITE)/TEXTURE/NORMAL_MAP types? ShaderVariable handling)
-- UI (delegates on click for buttons using std::function (Functions), elements created once and rendered, UIText and UIImage classes responsible for rendering, both deriving from UIRenderer (?), components, texts, shaders for texts and images, font loading)
-- Debug console rendered by texts on GUI, toggled by ~ (VK_OEM_3) (maybe commands?), console attaches itself to Debug::OnLog, gathers also commands (and marks them to be visible), colors?
-- imGUI for debug engine/game gui?
-- Stack printer (dbghlp.h?)
-- OctTree (constructed from MeshRenderers (or Entities?), camera::render should check octtree to determine which objects should be rendered)
-- MemoryManagers/Allocators (new and delete overrides, with lines and files parameters, Physx allocator)
-- RTTI (simple, T::GetType(), T::_type, Type::Get(typeName).CreateInstance(line, file), use functions for GetRTTIRegister() with static local variable in the function, Type::ConstructCopy(original), get rid of Component::Copy and Entity::Copy functions, use properties for easily serialize new types)
-- Archive and serialization (Archive as Utility clas? Archive* FileSystem::GetArchive(path)? Or new Archive(path)? Use XML, JSON, Binary or multiple for serialization? Serialization of Scene, Material, HexagonalGrid, GameObjects, Components? Serialization uses Archive class? Each object knows how to (de)serialize properly?)
-- Basic lighting (PhongBlinn? Lambert? ShaderVariable arrays handling maybe?)
-- Think about ComPtr from <wrl/client.h>
-- Think about engine's DLL and connecting it to other projects where game will be written (maybe some sort of registering game derrived class? or registering game by passing it to the App constructor/initializer?)
-- Move CameraControl and Selection systems to SampleTurnBasedStrategySample (after making DLL from engine project)
-- 3D object texturing (do not forget about updating shader reflection to easily provide access like material->Set("MainTexture", mainTexturePtr))
-- FBX loading (static meshes)
-- Animations (AnimationClip (loading from FBX (one or many), AnimationEvents), AnimationStateMachine (better namme would be nice), SkinnedMeshRenderer, skinning on GPU (it might be diffucult but according to Marcin it's the only way to achieve good performace))
-- Custom string class (unicode string? simple string?)
TODOs:
-- GameObject				|> ALL DONE
-- Component				|> ALL DONE
-- Scene					|> ALL DONE
-- Camera 					|> ALL DONE
-- Shader 					|> ALL DONE
-- MeshBase 				|> ALL DONE
-- MeshRenderer				|> ALL DONE
-- HexagonMesh 				|> ALL DONE
-- TriangleMesh				|> ALL DONE
-- CameraControl			|> IN PROGRESS (TODO: Raycasting, Camera::GetMainCamera()->ConvertScreenPointToRay()?)
-- Asset					|> ALL DONE
-- ResourceManager			|> ALL DONE
-- Transform hierarchy 		|> ALL DONE
-- Material 				|> ALL DONE
-- HexagonalGrid 			|> ALL DONE
-- QuadMesh					|> ALL DONE
-- PlaneMesh 				|> ALL DONE
-- SphereMesh				|> ALL DONE
-- CubeMesh					|> ALL DONE
-- CylinderMesh 			|> ALL DONE
-- ConeMesh					|> ALL DONE
-- CapsuleMesh				|> ALL DONE
-- StaticMesh				|> IN PROGRESS (TODO: fbx loading)
-- Cloning GameObjects		|> ALL DONE
-- Smart pointers, std::unique_ptr, std::shared_ptr, std::weak_ptr, std::move, std::forward
-- Rework architecture a little bit (no more gGraphics, gWindow and other things like that... maybe Singleton as some Utility class with static GetInstance creating instance and FreeInstance destroying instance?)
-- Textures (2D only for now, simple TGA/PNG loading, SPRITE/TEXTURE/NORMAL_MAP types?)
-- GUI (delegates on click for buttons using std::function, elements created once and rendered, GUIText and GUIImage classes responsible for rendering, components, rendering order (first scene then gui?), texts, shaders for texts and images, font loading)
-- Debug console rendered by texts on GUI, toggled by ~ (maybe commands?)
-- Physics (simple raycasting with PhysX? simple colliders box, sphere, capsule, cone, quad (also for plane), cylinder, hexagon)
-- MemoryManagers/Allocators (new and delete overrides, with lines and files parameters)
-- RTTI (simple, T::GetType(), T::_type, Type::Get(typeName).CreateInstance(line, file))
-- Archive (Utility class, Archive* FileSystem::GetArchive(path)? Or simple static function Archive::Get(path)?)
-- Serialization and deserialization for: Scene, Material, HexagonalGrid, GameObjects, Components (XML? JSON? Binary? Multiple? Archive class usage? Archive << operator? Archive.Begin(), Archive.End()? Objects responsible for loading/saving? Or Archive class is the one who knows how to serialize everything?)
-- Basic lighting (PhongBlinn? Lambert?)

ENGINE architecture/function order/lifetime cycle:
App::Initialize()
	Game::Initialize()	//Editor::Initialize()
		Scene::Load(basicScene)
			Scene::Unload()
			new GameObject
			GameObject::Initialize()	// No cross references allowed here
			GameObject::Load(someArchive)
				new Component
				Component::Initialize()	// No cross references allowed here
				Component::Load(someArchive)
		Scene::PostLoad()
			GameObject::PostLoad()		// Load references (since all objects are loaded)
				Component::PostLoad() 	// Load references (since all objects are loaded)
App::Loop()
	Game::Update(dt)	//Editor::Update(dt) (maybe some flag in GameObject bUpdatesWithEditor)
		Scene::Update(dt)
			GameObject::Update(dt)
				Component::Update(dt)	
	Game::Render()		//Editor::Render()
		Scene::Render()
			GameObject::Render()
				Component::Render()

App::Shutdown()
	Game::Shutdown()	//Editor::Shutdown()
		Scene::Unload()
			GameObject::Shutdown()
				Component::Shutdown()
			delete GameObject;
				delete Component;

Scene::Save()
	GameObject::PreSave()
		Component::PreSave()
	GameObject::Save(someArchive)
		Component::Save(someArchive)
TODOs:
-- GameObject								|> ALL DONE
-- Component								|> ALL DONE
-- Scene									|> ALL DONE
-- Camera 									|> ALL DONE
-- Shader 									|> ALL DONE
-- MeshBase 								|> ALL DONE
-- MeshRenderer								|> ALL DONE
-- HexagonMesh 								|> ALL DONE
-- TriangleMesh								|> ALL DONE
-- CameraControl							|> IN PROGRESS (TODO: Raycasting, Camera::GetMainCamera()->ConvertScreenPointToRay()?)
-- Asset									|> ALL DONE
-- ResourceManager							|> ALL DONE
-- Transform hierarchy 						|> ALL DONE
-- Material 								|> ALL DONE
-- HexagonalGrid 							|> ALL DONE
-- QuadMesh									|> ALL DONE
-- PlaneMesh 								|> ALL DONE
-- SphereMesh								|> ALL DONE
-- CubeMesh									|> ALL DONE
-- CylinderMesh 							|> ALL DONE
-- ConeMesh									|> ALL DONE
-- CapsuleMesh								|> ALL DONE
-- StaticMesh								|> IN PROGRESS (TODO: fbx loading)
-- Cloning GameObjects						|> ALL DONE
-- Smart pointers + architecture reworked	|> ALL DONE
-- Message passing 							|> ALL DONE
-- RnederingIssues.txt 						|> IN PROGRESS (TODO: Read about shader reflection in directx without Effects framework usage!)
-- Event classes							|> ALL DONE
-- Input adjusted to Delegate class 		|> ALL DONE
-- Debug class + logging					|> ALL DONE
-- Find a way to reflect shader's parameters (color, textures, floats etc.)
-- Resize window handling
-- Reorganize rendering architecture in DTEngine
-- Debug drawing lines, spheres, boxes etc. (visible only in DT_DEBUG builds, renderstates)
-- Textures (2D only for now, simple TGA/PNG loading, SPRITE/TEXTURE/NORMAL_MAP types?)
-- GUI (delegates on click for buttons using std::function (Functions), elements created once and rendered, GUIText and GUIImage classes responsible for rendering, components, texts, shaders for texts and images, font loading)
-- Debug console rendered by texts on GUI, toggled by ~ (VK_OEM_3) (maybe commands?), console attaches itself to Debug::OnLog, gathers also commands (and marks them to be visible), colors?
-- Physics (simple raycasting with PhysX? simple colliders box, sphere, capsule, cone, quad (also for plane), cylinder, hexagon)
-- MemoryManagers/Allocators (new and delete overrides, with lines and files parameters)
-- RTTI (simple, T::GetType(), T::_type, Type::Get(typeName).CreateInstance(line, file), use functions for GetRTTIRegister() whith static local variable in the function)
-- Archive (Utility class, Archive* FileSystem::GetArchive(path)? Or simple static function Archive::Get(path)?)
-- Serialization and deserialization for: Scene, Material, HexagonalGrid, GameObjects, Components (XML? JSON? Binary? Multiple? Archive class usage? Archive << operator? Archive.Begin(), Archive.End()? Objects responsible for loading/saving? Or Archive class is the one who knows how to serialize everything?)
-- Basic lighting (PhongBlinn? Lambert?)
-- Think about ComPtr from <wrl/client.h>
-- Think about engine's DLL and connecting it to other projects where game will be written (maybe some sort of registering game derrived class? or registering game by passing it to the App constructor/initializer?)
-- MATH library
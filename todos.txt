TODOs:
-- GameObject								|> ALL DONE
-- Component								|> ALL DONE
-- Scene									|> ALL DONE
-- Camera 									|> ALL DONE
-- Shader 									|> ALL DONE
-- MeshBase 								|> ALL DONE
-- MeshRenderer								|> ALL DONE
-- HexagonMesh 								|> ALL DONE
-- TriangleMesh								|> ALL DONE
-- CameraControl							|> IN PROGRESS (TODO: Raycasting, Camera::GetMainCamera()->ConvertScreenPointToRay()?)
-- Asset									|> ALL DONE
-- ResourceManager							|> ALL DONE
-- Transform hierarchy 						|> ALL DONE
-- Material 								|> ALL DONE
-- HexagonalGrid 							|> ALL DONE
-- QuadMesh									|> ALL DONE
-- PlaneMesh 								|> ALL DONE
-- SphereMesh								|> ALL DONE
-- CubeMesh									|> ALL DONE
-- CylinderMesh 							|> ALL DONE
-- ConeMesh									|> ALL DONE
-- CapsuleMesh								|> ALL DONE
-- StaticMesh (obj)							|> ALL DONE
-- Cloning GameObjects						|> ALL DONE
-- Smart pointers + architecture reworked	|> ALL DONE
-- Message passing 							|> ALL DONE
-- Event classes							|> ALL DONE
-- Input adjusted to Delegate class 		|> ALL DONE
-- Debug class + logging					|> ALL DONE
-- Resize window handling					|> ALL DONE
-- Renaming functions in Component 			|> ALL DONE
-- Asset reorganization 					|> ALL DONE
-- Reorganize rendering architecture		|> ALL DONE
-- Debug drawing lines, spheres, boxes 	 	|> ALL DONE
-- Reorganize transform structure 			|> ALL DONE
-- Rename GameObject to Entity				|> ALL DONE
-- Fix frustum culling						|> ALL DONE
-- Default material 						|> ALL DONE
-- Setting shader parameters (reflection)	|> ALL DONE
-- MATH library 							|> ALL DONE
-- Entity flags								|> ALL DONE
-- Physics									|> IN PROGRESS (TODO: read about PxScene, PxGeometry, PxShape, PxRigidbody, PxActor etc.; Think about physics architecture in DTEngine (colliders, rigidbodies, etc.); SceneQueries; Simulation filtering (layers?); hexagonal geometry; raycasting in CameraControl)
-- General config (fullscreen, vsync mode, target resolution etc.)
-- Fullscreen mode (maybe resizing is not properly handled)
-- Read a little bit about 2D rendering in DX11
-- Textures (2D only for now, simple TGA/PNG loading, SPRITE/TEXTURE/NORMAL_MAP types? ShaderVariable handling)
-- UI (delegates on click for buttons using std::function (Functions), elements created once and rendered, UIText and UIImage classes responsible for rendering, both deriving from UIRenderer (?), components, texts, shaders for texts and images, font loading)
-- Debug console rendered by texts on GUI, toggled by ~ (VK_OEM_3) (maybe commands?), console attaches itself to Debug::OnLog, gathers also commands (and marks them to be visible), colors?
-- Stack printer (dbghlp.h?)
-- OctTree (constructed from MeshRenderers (or Entities?), camera::render should check octtree to determine which objects should be rendered)
-- MemoryManagers/Allocators (new and delete overrides, with lines and files parameters, Physx allocator)
-- RTTI (simple, T::GetType(), T::_type, Type::Get(typeName).CreateInstance(line, file), use functions for GetRTTIRegister() with static local variable in the function, Type::ConstructCopy(original), get rid of Component::Copy and Entity::Copy functions)
-- Archive (Utility class, Archive* FileSystem::GetArchive(path)? Or simple static function Archive::Get(path)? For binary serialization)
-- Serialization and deserialization (Archive class) for: Scene, Material, HexagonalGrid, GameObjects, Components (XML? JSON? Binary? Multiple? Archive class usage? Archive << operator? Archive.Begin(), Archive.End()? Objects responsible for loading/saving? Or Archive class is the one who knows how to serialize everything?)
-- Basic lighting (PhongBlinn? Lambert? ShaderVariable arrays handling maybe?)
-- Think about ComPtr from <wrl/client.h>
-- Think about engine's DLL and connecting it to other projects where game will be written (maybe some sort of registering game derrived class? or registering game by passing it to the App constructor/initializer?)
-- Debug drawing: cone
-- Debug drawing: custom mesh
-- 3D object texturing (do not forget about updating shader reflection to easily provide access like material->Set("MainTexture", mainTexturePtr))
-- FBX loading
-- Animation class with virtual calls like Update(float deltaTime), SetAnimationFrame(int frame), SetAnimationTime(float time), SetAnimationNormalizedTime(float normalizedTime)
-- Animations loading
-- Animation renderer
-- Animation state machine with animations
-- Custom collections (array? linked list? dictionary/map? stack? queue? priority queue?)
-- Custom string class (unicode string? simple string?)
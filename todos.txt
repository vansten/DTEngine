TODOs:
-- GameObject								|> ALL DONE
-- Component								|> ALL DONE
-- Scene									|> ALL DONE
-- Camera 									|> ALL DONE
-- Shader 									|> ALL DONE
-- MeshBase 								|> ALL DONE
-- MeshRenderer								|> ALL DONE
-- HexagonMesh 								|> ALL DONE
-- TriangleMesh								|> ALL DONE
-- CameraControl							|> IN PROGRESS (TODO: Raycasting, Camera::GetMainCamera()->ConvertScreenPointToRay()?)
-- Asset									|> ALL DONE
-- ResourceManager							|> ALL DONE
-- Transform hierarchy 						|> ALL DONE
-- Material 								|> ALL DONE
-- HexagonalGrid 							|> ALL DONE
-- QuadMesh									|> ALL DONE
-- PlaneMesh 								|> ALL DONE
-- SphereMesh								|> ALL DONE
-- CubeMesh									|> ALL DONE
-- CylinderMesh 							|> ALL DONE
-- ConeMesh									|> ALL DONE
-- CapsuleMesh								|> ALL DONE
-- StaticMesh								|> IN PROGRESS (TODO: fbx loading)
-- Cloning GameObjects						|> ALL DONE
-- Smart pointers + architecture reworked	|> IN PROGRESS (TODO: ComPtr from Microsoft::WRL namespace?)
-- Message passing 							|> ALL DONE
-- Think about rendering UI (different renderer states - Opaque, Transparent, UI, render order, gathering and sorting renderers? Get rid of MeshRenderer::Render function and instead implement Camera::Render which will be responsible for rendering objects? Add callbacks OnWillRender() and OnPostRender() to Component class (i.e. for MeshRenderer and UIRenderer classes)? graphics.SetState(RendererState rs)?)
-- Textures (2D only for now, simple TGA/PNG loading, SPRITE/TEXTURE/NORMAL_MAP types?)
-- GUI (delegates on click for buttons using std::function (Functions), elements created once and rendered, GUIText and GUIImage classes responsible for rendering, components, texts, shaders for texts and images, font loading)
-- Debug console rendered by texts on GUI, toggled by ~ (VK_OEM_3) (maybe commands?)
-- Physics (simple raycasting with PhysX? simple colliders box, sphere, capsule, cone, quad (also for plane), cylinder, hexagon)
-- MemoryManagers/Allocators (new and delete overrides, with lines and files parameters)
-- RTTI (simple, T::GetType(), T::_type, Type::Get(typeName).CreateInstance(line, file))
-- Archive (Utility class, Archive* FileSystem::GetArchive(path)? Or simple static function Archive::Get(path)?)
-- Serialization and deserialization for: Scene, Material, HexagonalGrid, GameObjects, Components (XML? JSON? Binary? Multiple? Archive class usage? Archive << operator? Archive.Begin(), Archive.End()? Objects responsible for loading/saving? Or Archive class is the one who knows how to serialize everything?)
-- Basic lighting (PhongBlinn? Lambert?)

ENGINE architecture/function order/lifetime cycle:
One unique singleton - the App! Graphics, Window, ResourceManager, Time, Game, Input and (probably) Physics will be get by Get*() global function which in fact is App::GetInstance()->Get*() inlined call!

App::Initialize()
	Game::Initialize()	//Editor::Initialize()
		Scene::Load(basicScene)
			Scene::Unload()
			new GameObject
			GameObject::Initialize()	// No cross references allowed here
			GameObject::Load(someArchive)
				new Component
				Component::Initialize()	// No cross references allowed here
				Component::Load(someArchive)
		Scene::PostLoad()
			GameObject::PostLoad()		// Load references (since all objects are loaded)
				Component::PostLoad() 	// Load references (since all objects are loaded)
App::Loop()
	Game::Update(dt)	//Editor::Update(dt) (maybe some flag in GameObject bUpdatesWithEditor)
		Scene::Update(dt)
			GameObject::Update(dt)
				Component::Update(dt)	
	Game::Render()		//Editor::Render()
		Scene::Render()
			GameObject::Render()
				Component::Render()

App::Shutdown()
	Game::Shutdown()	//Editor::Shutdown()
		Scene::Unload()
			GameObject::Shutdown()
				Component::Shutdown()
			delete GameObject;
				delete Component;

Scene::Save()
	GameObject::PreSave()
		Component::PreSave()
	GameObject::Save(someArchive)
		Component::Save(someArchive)